{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FHIR-compliant Data Harmonization Framework for Cohort Studies","text":"<p>CDF2FHIR is a tool that transforms data from cohort studies given on a standard intermediate format into FHIR-compliant one in a way that (1) improves reusability by decoupling the transformation pairing rules from both input and output (FHIR) data formats, and (2) ensures a robust transformation process by enabling a test-driven approach for the development of these rules, in addition to other included run-time consistency validation features.</p> <p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p>"},{"location":"arch/","title":"CDF2FHIR overview","text":"<p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p> <p>CDF2FHIR, is a command line tool that performs a batch transformation process from cohort-study data into FHIR-compliant one. As illustrated in the diagram below, it uses as an input (1) the cohort data represented formatted with the CDF convention, and (2) a set of targets, that is to say the FHIR resources that are intended to be created based on the cohort data. </p> <p>Each target is defined, in turn, by selecting one of the previously defined FHIR templates (e.g., Problem, Condition, Laboratory result, etc.) and pairing it with a module where the logic of the transformation between the source and the target values is defined. </p> <p></p>"},{"location":"arch/#cdf2fhir-design-at-a-glance","title":"CDF2FHIR design at a glance","text":"<p>At its core, the CDF2FHIR tool is built on top of JSONata, a lightweight query and transformation language specifically designed for JSON data. JSONata provides a simple yet powerful syntax for extracting, filtering, and transforming data within JSON documents. The language supports a wide range of built-in functions, including $map, $filter, $sort, $reduce, and $merge, among others. These functions allow for sophisticated data manipulation and transformation tasks, such as transforming an array of values, filtering values based on a specific condition, sorting values, reducing an array to a single value, and merging multiple objects into one. </p> <p>To illustrate how CDF2FHIR extends and tailor JSONata for health-data transformation purposes, let's examine how a transformation would be performed using only the core of JSONata. Assume that the variable on input data below will be used to generate part of a FHIR blood-lab test resource. In this case, the 'interpretation' element of the target FHIR resource need to be included with the SNOMED code 281302008 only if the value of the hba1cconc_result_all_m_1 variable, in assessment '1a' is above 42.</p> <pre><code>{\n    \"hba1cconc_result_all_m_1\":{ \"1a\": \"43\", \"2a\":\"44\"},\n}\n</code></pre> <p>Using JSONata's syntax, this 'transformation rule' could be implemented as follows:</p> <pre><code>...\n{\n \"interpretation\": hba1cconc_result_all_m_1[\"1a\"] &gt; 42 ? {\n    \"coding\": [\n      {\n        \"system\": \"http://snomed.info/sct\",\n        \"code\": 281302008\n      }\n    ]\n } : {}\n}\n...\n</code></pre> <p>Although the output generated by the expresion above would be valid, having the output format coupled with the logic would make the process of implementing these rules at scale (multiple variables, for multiple datasets) time cosuming and unreliable. On the one hand, the format-related elements would be duplicated across every variant of a resource (e.g., having the format of the LabTestResult FHIR duplicated across multiple types of blood tests), leading to maintainability issues. On the other hand, this coupling makes it cumbersome to ensure accuracy and robustness of the rules by impeding proper testing. Moreover, the generation of consistent and valid FHIR resources involves other complex tasks, including the computation of unique identifiers, and using them consistently to make references between resources. </p> <p>The CDF2FHIR tool adds robustness and a proper separation of concerns by hiding most of this complexity from the process. As illustrated in the diagram below, the tool provides (1) a series of reusable templates for generating multiple types of FHIR resources (and a development environment to create new ones if needed), and (2) a series of libraries with the functions needed for the implementation of the pairing rules, incluiding the processing of the input data, and the management of coding systems (SNOMED, Loinc, etc). With this, to include a given FHIR resource as part of the transformation output, all that is needed is to implement the pairing rules as a TypeScript module (following an TypeScript interface previously defined, which enforces types consistency). </p> <p></p> <p>These pairing-rule modules, by being decoupled from the 'output-generation' concerns, can be developed following a test-based approach. That is to say, by first specifying the pairing rules, and then developing a series of test cases to guide the actual implementation. Let's illustrate this with the especification of a rule describing how to transform two variables from the original input dataset, into the 'result' element of a LaboratoryTestResult FHIR resource:</p> <pre><code>/**\n * A laboratory result describes the result of a laboratory analysis. These are specimen-oriented \n * tests as performed in laboratories such as Clinical Chemistry, Serology, Microbiology, etc. \n * In addition to the results of tests with a singular result, this concept can also contain \n * the results of more complex tests with multiple results or a \u2018panel\u2019.\n * \n * \n * Related variables:\n * ------------------------------------------------------------------\n *                                [1A][1B][1C][2A][3A][3B]\n * creatinine_result_all_m_1      [X ][  ][  ][X ][  ][  ]\n * date                           [X ][X ][X ][X ][X ][X ]\n * ------------------------------------------------------------------\n * \n * @return, for each assessment:\n *      [[assessment_N]:\n *          - result: creatinine_result_all_m_1 in assessment_N\n *          - resultcoding: {\"system\": \"http://loinc.org\",\"code\": \"14682-9\",\"display\": \"Creat SerPl-sCnc\"}\n *          - resultunits: {\"unit\": \"umol/l\",\"system\": \"http://unitsofmeasure.org\",\"code\": \"umol/L\"}\n *          - resultFlag: if gender == male:\n *                            if creatinine_result_all_m_1 in assessment_N &gt; 110.0 mmol/L:\n *                               {code:281302008, system:http://snomed.info/sct}\n *                            elif creatinine_result_all_m_1 in assessment_N &lt; 50.0 mmol/L:\n *                               {code:281300000, system:http://snomed.info/sct}\n *                        elif gender == female:\n *                            if creatinine_result_all_m_1 in assessment_N &gt; 90.0 mmol/L:\n *                               {code:281302008, system:http://snomed.info/sct}\n *                            elif creatinine_result_all_m_1 in assessment_N &lt; 50.0 mmol/L:\n *                               {code:281300000, system:http://snomed.info/sct}\n *          - collectedDateTime: date of assessment_N         \n * \n */\n\nexport const creatinine:LaboratoryTestResult = \n...\n</code></pre> <p>Based on this specification, test cases like the following, could be implemented for multiple scenarios to ensure a correct implementation what was specified:</p> <pre><code>test('Creatinine conceptration for male participant, above limit', () =&gt; {\n\n  const input = {\n\n    \"creatinine_result_all_m_1\" :{ \"1a\": \"111\", \"2a\":\"120\"},//in mmol/L\n    \"gender\" : { \"1a\":\"MALE\"},\n    \"date\": {/*date1*/ \"1a\":\"1990-1\",\"1b\":\"1995-5\",\"1c\":\"1997-5\",/*date2*/\"2a\":\"2000-1\",\"3a\":\"2003-5\",\"3b\":\"2005-5\"},\n    \"age\": { \"1a\": \"40\" },  //age on \"2a\": 50  \n    \"project_pseudo_id\": { \"1a\": \"520681571\" },\n  }  \n\n\n  InputSingleton.getInstance().setInput(input);\n  const results = creatinine.results();\n  expect(results.length).toBe(2);  \n  expect((results[0] as TestResultEntry).testResult).toBe(111)\n  expect((results[0] as TestResultEntry).resultFlags?.display).toBe(\"Above reference range\")\n  expect((results[1] as TestResultEntry).testResult).toBe(120)  \n  expect((results[1] as TestResultEntry).resultFlags?.display).toBe(\"Above reference range\")\n\n\n});\n</code></pre> <p>Once the modules with the pairing rules are developed, the tool 'injects' all the functions (standard ones, and the ones created for the pairing rules) on each JSONata templates, according to series of 'Mapping targets', a configuration defining which pairing rules will be used with which templates.</p> <p>Once all the templates are created, the bach process of the diagram below is performed: each input resource (which correspond to a single cohort study participant) is transformed into multiple FHIR resources, which are then linked and aggregated as a single FHIR resource.</p> <p></p>"},{"location":"fhirvalidation/","title":"FHIR validation","text":"<p>Work in progress</p>"},{"location":"ftemplates/","title":"FHIR templates creation","text":"<p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p> <p>Work in progress</p> <ul> <li>JSONata reference - operators</li> <li> <p>Tool-specific/pairing rule interface functions</p> <p>$results() $isDefined() $idToUUID $resourceID</p> </li> </ul>"},{"location":"ftemplates/#defining-an-output-template","title":"Defining an output template","text":"<p>Templates that can be reused:</p> <ul> <li>Problem/Condition</li> <li>Laboratory result</li> </ul> <p>For other specific MedMij resources, a template need to be created from the technical information from Nictiz. For example, Vaccination/Immunization- the following referneces would be useful:</p> <ul> <li> <p>Vaccination/Immunization- profile (structure definition)- requires checking (url) https://simplifier.net/packages/nictiz.fhir.nl.stu3.zib2017/1.3.4/files/113799</p> </li> <li> <p>ZIBs documentation: https://zibs.nl/wiki/HCIM_Release_2017(EN)</p> </li> <li> <p>Vaccination/Immunization- examples. By checking the cardinality specified in the previous two, it can be identified which elements are not considered in the example https://simplifier.net/packages/nictiz.fhir.nl.stu3.zib2017/2.2.12/files/2002637</p> </li> </ul> <p>Create a file with .jsonata extension</p>"},{"location":"ftemplates/#automatic-generationcross-reference-of-uuids","title":"Automatic generation/cross-reference of UUIDs","text":""},{"location":"ftemplates/#fhir-resources-1-01","title":"FHIR resources (1 &lt;-&gt; 0..1)","text":"<p>$resourceId function</p> <pre><code>$resourceId('zib-hypertension')\n</code></pre>"},{"location":"ftemplates/#fhir-resources-1-0n","title":"FHIR resources (1 &lt;-&gt; 0..N)","text":"<p>$waveSpecificResourceId function</p> <pre><code>$waveSpecificResourceId('zib-laboratorytestresult-specimen-hdl',$result.assessment)\n</code></pre>"},{"location":"prules/","title":"Creating new pairing rules","text":"<p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p> <p>As described on the architecture section, the CDF2FHIR performs a batch process where a set of previously defined pairing rules are applied </p> <ul> <li>Existing interfaces<pre><code>LaboratoryTestResults\n</code></pre> </li> </ul> <p>Implementing the interfaces</p> <pre><code>Typesystem\n</code></pre> <p>API</p> <pre><code>getting the value of a variable for a given assessment\n    inputValue(\"gender\",\"1a\");\n\nSometimes the output depends on whether the asessment on a given wave was performed or not\n\n    assessmentMissed(\"\")\n\nAssertions that abort the transformation of the current patient:\n\n\n    assertIsDefined(inputValue(\"date\",\"1a\"),`Precondition failed: date of baseline assessment (1a) is expected to be not-null for eGFR calculations`)\n</code></pre> <p>Getting codes: SNOMED, LOINC, ... //error when non existing</p>"},{"location":"prules/#test-driven-development","title":"Test-driven-development","text":"<ol> <li>Pick template/interface</li> <li>Add specification for the functions</li> <li>Test case implementation - use equivalence classes partitioning or other approaches</li> </ol> <p>test('eGFRS for male, black participant', () =&gt; {</p> <p>const input = {</p> <pre><code>\"creatinine_result_all_m_1\":{ \"1a\": \"79.2\", \"2a\":\"106.1\"},//in umol/L\n\"ethnicity_category_adu_q_1\":{\"1b\":\"3\"},\n\"gender\" : { \"1a\":\"MALE\"},\n\"date\": {/*date1*/ \"1a\":\"1990-1\",\"1b\":\"1995-5\",\"1c\":\"1997-5\",/*date2*/\"2a\":\"2000-1\",\"3a\":\"2003-5\",\"3b\":\"2005-5\"},\n\"age\": { \"1a\": \"40\" },  //age on \"2a\": 50  \n\"project_pseudo_id\": { \"1a\": \"520681571\" },\n</code></pre> <p>}  </p> <p>InputSingleton.getInstance().setInput(input);   const results = eGFRS.results();   expect(results.length).toBe(2);   expect((results[0] as TestResultEntry).testResult).toBeCloseTo(124,0)   expect((results[0] as TestResultEntry).resultFlags).toBe(undefined)   expect((results[1] as TestResultEntry).testResult).toBeCloseTo(81,0)   expect((results[1] as TestResultEntry).resultFlags).toBe(undefined)</p> <p>});</p>"},{"location":"prules/#defining-a-module","title":"Defining a module","text":"<p>import the following libraries:</p> <pre><code>import {inputValue, inputValues} from '../functionsCatalog';\nimport moize from 'moize'\nimport {lifelinesDateToISO, lifelinesMeanDate} from '../lifelinesFunctions'\nimport {clinicalStatusSNOMEDCodeList,conditionsSNOMEDCodeList,verificationStatusSNOMEDCodeList} from '../snomedCodeLists';\n</code></pre> <ul> <li>inputValue: get the input value from a given wave/assessment</li> </ul> <pre><code>inputValue(&lt;variable name&gt;,&lt;wave&gt;)\n</code></pre> <ul> <li>inputValues: get the map of all the wave values</li> </ul> <p><pre><code>const val = inputValue(&lt;variable name&gt;)\n</code></pre> * moize</p> <p>caching expensive computations (used multiple times within the template)</p> <ul> <li>Coding system libraries</li> </ul>"},{"location":"prules/#fhir-resources-1-01","title":"FHIR resources (1 &lt;-&gt; 0..1)","text":"<p>From the available data, the output is a single resource (e.g., Diabetes condition )</p>"},{"location":"prules/#fhir-resources-1-0n","title":"FHIR resources (1 &lt;-&gt; 0..N)","text":"<p>Resources that represent a change over time. Multiple resources are generated.</p>"},{"location":"prules/#testing","title":"Testing","text":"<p>resource.test.ts</p> <p>Testing the module functions independently (not using then in the mapping)</p> <pre><code>//To set the input of the transformation\nimport { InputSingleton } from '../inputSingleton';\n//The module to be tested\nimport * as problemXmod from '../lifelines/MyProbXModule'\n//Other modules required for the test, e.g., modules with codes\nimport { clinicalStatusSNOMEDCodeList, conditionsSNOMEDCodeList, verificationStatusSNOMEDCodeList } from '../snomedCodeLists';\n\n//set the input\nconst input = {\n    \"varOne\":{\"W1\":\"2\",\"W2\":\"5\"},\n    \"varTwo\":{\"W1\":\"1\",\"W2\":\"9\"},\n}\n\nInputSingleton.getInstance().setInput(input);\n\nexpect(problemXmod.functionToBeTested()).toBe(&lt;expected value&gt;);\n</code></pre> <p>Testing the functions through the mapping process</p> <pre><code>//To set the input of the transformation\nimport { InputSingleton } from '../inputSingleton';\n//The module to be tested\nimport * as problemXmod from '../lifelines/MyProbXModule'\n//Other modules required for the test, e.g., modules with codes\nimport { clinicalStatusSNOMEDCodeList, conditionsSNOMEDCodeList, verificationStatusSNOMEDCodeList } from '../snomedCodeLists';\n//The mapper, to generate the FHIR bundle with the given input\nimport { MappingTarget, processInput } from '../mapper'\n\n//set the input\nconst input = {\n    \"varOne\":{\"W1\":\"2\",\"W2\":\"5\"},\n    \"varTwo\":{\"W1\":\"1\",\"W2\":\"9\"},\n}\n\n\nconst targets: MappingTarget[] = [\n    { \"template\": './zib-2017-mappings/ProblemXtemplate', \"module\": './lifelines/MyProbXModule' },\n  ]\n\n//Process the template, using the module, then evaluate the output (an array of FHIR resources to be included in the bundle). Ref to description of 1-to-* and 1-to-1.\nprocessInput(input, targets).then((output: object[]) =&gt; {\n    //test\n    expect(output.length).toBe(1);\n\n})\n</code></pre>"},{"location":"uienv/","title":"UI validation","text":"<p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p>"},{"location":"wip/","title":"Work in progress","text":"<p>Under Development</p> <p>This tool is under active development. The documentation is not complete yet. If you have any  questions, please contact us via GitHub Issues</p>"}]}